/**
\page designhandlers Handlers

All asynchronous operations take a function object that will be called when the
operation completes. The type of the function object is a template parameter,
like so:

@code
template <typename Handler>
void async_wait(Handler handler);
@endcode

An alternative approach might have been to make the callback parameter a
boost::function object:

@code
void async_wait(boost::function<void(error&)> f);
@endcode

This approach was not used because of the performance penalty incurred by using
boost::function objects, as each function object's implementation contains a
dynamically allocated object.

Some asynchronous operations must already allocate an object with a lifetime of
the duration of the operation. For example, the Win32 backend creates objects
that are derived from the OVERLAPPED structure. These dynamically allocated
objects can contain a copy of the handler object, and if a boost::function was
used it would entail two memory allocations instead of one.

The chosen design still allows the user to pass boost::function objects as
their callback handler. It also permits a backend implementation that is
implemented using boost::function objects, but doesn't require it.

*/
