/**
\page designproactor Proactor

The asio library is based on the Proactor pattern [1]. This design note outlines
the advantages and disadvantages of this approach.

\section designproactoradv Advantages

\par Portability

The library interface can be reused independently of the operating system's
underlying demultiplexing mechanism [1]. The Proactor interface may be
implemented using a range of event sources, including the synchronous event
demultiplexers that typify the Reactor pattern, such as select.

\par Decoupling threading from concurrency

Long-duration operations are performed asynchronously by the Proactor on behalf
of the application. Consequently applications do not need to spawn many threads
in order to increase concurrency [1].

\par Performance

Implementation strategies such as thread-per-connection can degrade system
performance, due to increased context switching, synchronization and data
movement among CPUs [1]. The Proactor pattern can avoid the cost of context
switching by minimising the number of operating system threads, and only
activating the logical threads of control that have events to process.

\par Simplified application synchronisation

Asynchronous operation completion handlers can be written as though they exist
in a single-threaded environment, and so application logic can be developed
with little or no concern for synchronisation issues [1].

\par Function composition

Function composition refers to the implementation of functions to provide a
higher-level operation, such as sending a message in a particular format. Each
function is implemented in terms of multiple calls to lower-level read or write
operations.

For example, consider a protocol where each message consists of a fixed-length
header followed by a variable length body, where the length of the body is
specified in the header. A hypothetical read_message operation could be
implemented using two lower-level reads, the first to receive the header and,
once the length is known, the second to receive the body.

To compose functions in a Proactor model, asynchronous operations can be
chained together. That is, a completion handler for one operation can initiate
the next. Starting the first call in the chain can be encapsulated so that the
caller need not be aware that the higher-level operation is implemented as a
chain of asynchronous operations.

The ability to compose new operations in this way simplifies the development of
higher levels of abstraction above a networking library, such as functions to
support a specific protocol.

\section designproactordisadv Disadvantages

\par Program complexity

It is more difficult to develop applications using asynchronous mechanisms due
to the separation in time and space between operation initiation and completion
[1]. Applications may also be harder to debug due to the inverted flow of
control.

\par Memory usage

Buffer space must be committed for the duration of a read or write operation,
which may continue indefinitely, and a separate buffer is required for each
concurrent operation. The Reactor pattern, on the other hand, does not require
buffer space until a socket is ready for reading or writing.

\section designproactorrefs References

[1] D. Schmidt et al, <i>Pattern Oriented Software Architecture, Volume 2</i>.
Wiley, 2000.

*/
